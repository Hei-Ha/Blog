## nodeJS 的垃圾回收机制

### node 和 V8

&emsp;&emsp;Node 的快速发展得益于 V8 引擎，V8 的性能优势使得开发者可以使用 `javascript`
编写高性能的后台服务程序，并且可以随着 `V8` 的升级，就能享受到更好的性能或者新的语言特性（如ES5 和 ES6）等，同时也受 `V8`
的一些限制，比如接下来要说的 内存限制。    

&emsp;&emsp; `Javascript` 和 `Java` 一样，都是由垃圾回收机制来进行自动内存管理，这使得开发者不需要像 `c/c++`
程序员那样，在编写代码的过程中时刻关注着内存的分配和释放问题。在浏览器中进行开发时，很少有人能遇到垃圾回收对应用程序的性能构成影响。
但 `Node` 极大的拓宽了 `Javascript`的应用场景，当应用场景从客户端拓展到服务器端后就会发现，对于性能敏感的服务器端程序，内存管理的好坏，垃圾回收情况是否优良，都会对服务构成影响。

### V8 的内存限制
&emsp;&emsp;在 `Node` 中通过 `Javascript` 使用内存时会发现只能使用部分内存。在这样的限制下，将会导致 `Node`
无法直接操作大内存对象，比如无法将一个 2GB 的文件读入内存中进行处理，即使物理内存超过 2GB,这样在单个 `Node`
进程的情况下，计算机的内存资源无法得到充足的使用。
造成这个问题的主要原因是由于 `Node` 基于 `V8` 构建，所以在 `Node` 中使用的 `Javascript` 对象基本上都是通过 `V8`
自己的方式来进行分配和管理的，但在 Node 开发中，这却限制了开发者随心所欲使用大内存的想法。

### V8 的对象分配

&emsp;&emsp;在 `V8` 中 所有的 `Javascript` 对象都是通过堆来进行分配的。
当开发者在代码中声明变量并赋值时，所使用对象的内存就分配在 堆 中。如果已经申请的 堆
空闲内存不够分配新的对象，将继续申请堆内存，直到堆的大小超过 `V8` 的限制为止。

至于 `V8` 为什么要限制堆的大小  
表层原因是 `V8` 为最初浏览器而设计，不太可能遇到使用大量内存的场景，对于网页来说，`V8`的限制已经绰绰有余。  
深层原因是 `V8` 的垃圾回收机制的限制。按官方的说法，以 `1.5GB` 的垃圾回收堆内存为例，`V8` 做一次小的垃圾回收需要 `50ms`  

以上，做一次非增量式的垃圾回收甚至需要 `1s` 以上。这是垃圾回收中引起 `Javascript` 线程暂停执行的时间，在这样的时间花销下，应用程序的性能和相应能力都会直线下降。这样的情况不仅仅是后端服务无法接受，前端浏览器也无法接受。因此，在当时直接考虑限制堆内存是一个好的选择。

当然这个限制也不是不能打开，V8 提供了选项让开发者可以使用更多的内存。在启动 Node
服务时可以传递一些参数来调整内存限制的大小：

```shell
node --max-old-space-size=1700 test.js # 单位为MB 
# 或者
node --max-new-space-size=1024 test.js # 单位为KB
```

上述的参数在 `V8` 初始化的时候就生效，一旦生效就不能再动态改变。

### V8 的垃圾回收机制

**V8 的垃圾回收策略主要基于 分代式垃圾回收机制，分为：新生代、老生代。**  

&emsp;&emsp;在自动垃圾回收演变的过程中，人们发现没有一种垃圾回收算法能胜任所有的场景，因为在实际的应用中，对象的生存周期长短不一
，不同的算法只能对特定的情况达到最好的效果。为此，统计学在计算垃圾回收算法的发展中产生了较大的作用，现在的垃圾回收算法中按对戏那个的存活时间，将内存中的垃圾回收进行不同的分代，然后分别对不同的分代内存施以更高效的算法。

#### V8 的内存分代

&emsp;&emsp;在 `V8` 中，主要将内存分为新生代，老生代，两代。新生代中的对象为存活时间比较短的对象。老生代中的对象，为存活时间较长
或者常驻内存的对象。  

&emsp;&emsp;`V8` 的整体大小就是新生代、老生代所用内存空间的总和。前面提到的设置内存的命令行参数，就是分别设置新、老生代内存大小的命令行参数。比较遗憾的是，这两个最大值需要在启动的时候就设置好。这意味着
`V8` 使用的内存没有办法根据使用情况自动扩充，当内存分配过程中超过极限值时，就会引起进程出错。

#### Scavenge 算法
&emsp;&emsp;在分代的基础上，新生代中的对象主要通过 `Scavenge` 算法进行垃圾回收。  
在 Scavenge 的具体实现中，主要采用了 Cheney 算法。  

&emsp;&emsp;Cheney 算法是一种采用复制的方式实现的垃圾回收算法。它将堆内存一分为二，每一部分空间成为 `semispace` 。在这两个 `semispace` 空间中，只有一个处于使用状态，另一个处于闲置状态。处于使用状态的空间称为 `From` 空间，处于闲置状态的空间称为 `To` 空间。

&emsp;&emsp;当开发者分配对象时，先是在 `From` 空间中进行分配。当开始进行垃圾回收时，会检查 `From` 空间中的存活对象，这些存活对象将被复制到 `To` 空间中，而非存活对象占用的空间将会被释放。完成复制后，`From` 空间和 `To` 空间的角色发生对换。
`Scavenge` 的缺点是只能使用 堆内存的一半，这是由于划分空间和复制机制所决定的。但是 `Scavenge` 由于只复制存活的对象，
并且对于生命周期短的场景，存活对象只占少部分，所以它在时间效率上有有益的表现。  

&emsp;&emsp;由于 `Scavenge` 是典型的牺牲空间换时间的算法，所以无法大规模的应用到所有的垃圾回收中，但是可以发现, `Scavenge` 非常适合应用在新生代中，因为新生代中的对象生命周期比较短，刚好适合这个算法。

**当一个对象经过多次复制依然存活时，它将会被认为是生命周期较长的对象。这种较长生命周期的对象随后会被移动到老生代中，采用新的算法进行管理。对象从新生代到老生代中的过程称为晋升。**  

&emsp;&emsp;在单纯的 `Scavenge` 中，`From` 空间中存活的对象会被复制到 `To` 空间中去，然后对 `From` 空间和 `To` 空间 进行角色对换。但在分代式垃圾回收的前提下，`From` 中的存活对象 复制到 `To` 之前，需要进行检查。在一定条件下，需要将存活周期长的对象移动到老生代中，也就是完成对象的晋升。

晋升的条件主要有两个，一个是对􏱷是否经􏳻过 `Scavenge` 􏲧收，一个是 `To` 􏵷􏰳的内存占用比例是否超过限制。  

&emsp;&emsp;默认情况下，V8 的对象分配主要集中在 `From` 空间中，对象从 `From` 空间中复制到 `To` 空间时，会检查它的内存地址来判断这个对象是否已经经历过一次 `Scavenge` 回收。如果已经经历过，会将该对象从 `From` 空间复制到老生代空间中，如果没有，则复制到 `To` 空间中。这个晋升的流程图下图所示：
<img src="https://static.wangchuang.space/Images/Blogs/nodeJS/对象晋升1.png" width="300px" height="300px" />
&emsp;&emsp;另一个判断条件是 `To` 空间的内存占用比。当要从 `From` 空间复制一个对象到 `To` 空间时，如果 `To` 空间已经使用了超过 25%，则这个对象直接晋升到老生代空间中，如下图所示：
<img src="https://static.wangchuang.space/Images/Blogs/nodeJS/对象晋升2.png" width="300px" height="300px" />
设置 25% 这个限制的原因是当这次 `Scavenge` 回收完成后，这个 `To` 空间将变成 `From` 空间，接下来的内存分配将在这个空间进行，如果占比过高，会影响后续的内存分配

#### Mark-Sweep & Mark-Compact
对于老生代中的对象，由于存活对象占较大比重，如果再采用 `Scavenge` 方式，会有两个问题：
- 一个是存活对象较多，复制存活对象的效率将会很低；
- 另一个问题依然是浪费一半空间的问题。 

&emsp;&emsp;这两个问题导致对应生命周期较长的对象进行 `Scavenge` 时，会显得捉襟见肘。因此 V8 在老生代中主要采用了 `Mark-Sweep` 和 `Mark-Compact` 相结合的方式进行垃圾回收。

&emsp;&emsp;`Mark-Sweep` 是标记清除的意思，它分为标记和清除两个阶段。与 `Scavenge` 相比，`Mark-Sweep` 并不将内存空间划分为两半，所以不存在浪费一半空间的行为。与 `Scavenge` 复制存活对象不同，`Mark-Sweep` 在标记阶段遍历堆中的所有对象，并标记或者的对象，在随后的清除阶段中，只清除没有被标记的对象。  

&emsp;&emsp;可以看出，`Scavenge` 中只复制或者的对象，而 `Mark-Sweep` 只清理死亡对象。活对象在新生代中只占较小部分，死对象在老生代中只占小部分，这是两种回收方式能高效处理的原因。

&emsp;&emsp;`Mark-Sweep` 最大的问题是在进行一次标记清除回收后，内存空间会存在不连续的状态。，这种内存碎片会对后续的内存分配造成问题，因为很可能出现需要分配一个大对象的情况，这时所有的碎片空间都无法完成此次分配，就会提前出发垃圾回收，而这次回收是不必要的。


**为了解决 Mark-Sweep 内存碎片的问题， Mark-Compact 被提出来。**   
`Mark-Compact` 是标记整理的意思，是在 `Mark-Sweep` 的基础上演变而来的。它们的差别在于对象被标记为死亡后，在整理的过程中，将活着的对象往一端移动，移动完成后，直接清理掉边界外的内存。

在 `V8` 中，两者是结合使用的，由于 `Mart-Compact` 需要移动对象，所以它的执行速度不可能很快，所以在取舍上，`V8` 主要使用 `Mark-Sweep` 在空间不足以对从新生代中晋升过来的对象进行分配时，才使用 `Mark-Compact`。  

#### Incremental Marking
&emsp;&emsp;为了避免出现 `Javascript` 应用逻辑与垃圾回收器看到的不一致情况，垃圾回收的三种基本算法都要将应用逻辑暂停下来，待执行完回收后，再恢复执行应用逻辑，这种行为被称为“全停顿”。  

&emsp;&emsp;在 `V8` 的分代式垃圾回收中，一次小的垃圾回收只收集新生代，由于新生代默认配置的较小，且其中存活对象通常较少，所以即便它是全停顿的影响也不大。但 `V8` 的老生代通常配置的较大，且存活对象较多，全堆垃圾回收（full 垃圾回收）的标记、清理、整理等动作造成的停顿就会比较可怕，需要设法改善。  

&emsp;&emsp;为了降低全堆垃圾回收带来的停顿时间，`V8` 先从标记阶段入手，将原本需要一口气停顿完成的动作改为增量标记，也就是拆分为许多小“步进”，每做完一步，就让 `Javascript` 应用逻辑执行一小会，垃圾回收与应用逻辑交替执行到标记阶段完成。
V8 在经过增量标记的改进之后，垃圾回收的最大停顿时间可以减少到原来的 1/6 左右。  

*额外备注：*
V8 后续还引入了延迟清理（lazy sweeping）和 增量式整理(incremental compaction)，让清理与整理动作也变成增量式的。同时还计划引入并行标记与并行清理，进一步利用多核性能降低每次停顿的时间，